#!/usr/bin/env python

# from __future__ import division

import os, sys


import optparse, os, sys
op = optparse.OptionParser(usage=__doc__)
op.add_option("--resume",       dest="RESUME",    default=False, action='store_true', help="Resume on previous run.")
op.add_option("--multi-mod",    dest="MULTIMODE", default=False, action='store_true', help="Set multimodal to true.")
op.add_option("--update",       dest="UPDATE",    default=1000, type=int, help="Update inteval (default: %default iterations)")
op.add_option("-o", "--output", dest="OUTPUT",    default="nestout", type=str, help="Prefix for outputs (default: %default)")
op.add_option("--tol",          dest="TOL",       default=0.5, type=float, help="Evidence tolerance (default: %default)")
op.add_option("--eff",          dest="EFF",       default=0.8, type=float, help="Sampling efficiency (default: %default)")
op.add_option("--points",       dest="POINTS",    default=400, type=int,              help="Number of live points in PyMultinest (default: %default)")
op.add_option("--sigma",       dest="SIGMA",    default=1, type=int,              help="Switch to inflate the error in likelihood (default: %default)")
op.add_option("--seed",       dest="SEED",    default=-1, type=int,              help="Multinest seed (default: %default)")
op.add_option("--ordering",     dest="ORDERING",  default=0, type=int,                help="The mass ordering (0 or 1, default: %default)")
op.add_option("--nds",     dest="NDECST",  default=1, type=int,                help="Number of decaying steriles (1 or 2, default: %default)")
op.add_option("--approx",     dest="APPROX",  default=False, action='store_true',     help="Use approximate equations (default: %default)")
op.add_option("--testloopdom",     dest="TESTLOOPDOM",  default=False, action='store_true',     help="Use approximate equations (default: %default)")
op.add_option("--testtreedom",     dest="TESTTREEDOM",  default=False, action='store_true',     help="Use approximate equations (default: %default)")
op.add_option("-v", "--debug",  dest="DEBUG",     default=False, action="store_true", help="Turn on some debug messages")
op.add_option("-q", "--quiet",  dest="QUIET",     default=False, action="store_true", help="Turn off messages")
opts, args = op.parse_args()

import leptomts
RNG, FIX = leptomts.readConfig(args[0])

if "M1" in FIX.keys():
    if not "M2" in FIX.keys() and not "M2" in RNG.keys():
        FIX["M2"]=FIX["M1"]+0.5#49831055378960054
    if not "M3" in FIX.keys() and not "M3" in RNG.keys():
        FIX["M3"]=FIX["M2"]+0.5#9831055378960054


# Sanity check for ordering
if opts.ORDERING not in [0,1]:
    print( "Error, ordering has to be either 0 or 1, exiting")
    sys.exit(1)

# Output directory
rank=0
try:
    from mpi4py import MPI
    comm = MPI.COMM_WORLD
    size = comm.Get_size()
    rank = comm.Get_rank()
    print("[%i]/[%i] reporting for duty"%(rank, size))
except Exception as e:
    print("Problem:", e)
    pass

try:
    os.makedirs(opts.OUTPUT)
except:
    pass

print("[%i] Writing output to"%rank, opts.OUTPUT)
# Paramter names
PNAMES = list(RNG.keys())

# Scaling info
PMIN   = [x[0] for x in list(RNG.values())]
PMAX   = [x[1] for x in list(RNG.values())]
PLEN   = [PMAX[i] - PMIN[i] for i in range(len(PMAX))]

# Number of dimensions our problem has
NP = len(PMIN)


import leptomts

LEPTO=leptomts.LeptoCalc(nds=opts.NDECST, approx=opts.APPROX)

def scaleParam(p, idx):
    return PMIN[idx] + p * PLEN[idx]

def myprior(cube, ndim, nparams):
    for i in range(ndim):
        cube[i] = scaleParam(cube[i], i)

def loglike(cube, ndim, nparams):
    PP=[cube[j] for j in range(ndim)]
    pdict=FIX.copy()
    pdict["ordering"]=opts.ORDERING

    for num, p in enumerate(PNAMES):
        pdict[p]=cube[num]

    if "M1" in RNG.keys():
        if not "M2" in FIX.keys() and not "M2" in RNG.keys():
            pdict["M2"]=pdict["M1"]+0.5#49831055378960054
        if not "M3" in FIX.keys() and not "M3" in RNG.keys():
            pdict["M3"]=pdict["M2"]+0.5#9831055378960054

    if opts.DEBUG:
        print( "Testing point", PP)

    LEPTO.setParams(pdict)
    pert = LEPTO.isPerturbative
    if not pert:
        if opts.DEBUG:
            print( "Vetoing point", PP)
        return -1e101

    if opts.TESTTREEDOM:
        meas = LEPTO.FTmeasure()
        if meas > 0.2:
            if opts.DEBUG:
                print( "Vetoing point because it is not tree dominant")
            return -1e101
        if opts.DEBUG:
            return -1e101

    if opts.TESTLOOPDOM:
        meas = LEPTO.FTmeasure()
        if meas > 1.1 or meas < 0.9:
            if opts.DEBUG:
                print( "Vetoing point because it is not loop dominant")
            return -1e101

    try:
        ymodel = LEPTO.EtaB
    except:
        print( "Something went wrong at", PP, "vetoing")
        return -1e101

    if opts.DEBUG:
        print("response", ymodel)

    ydata = 6.10e-10
    yerr  = 0.04e-10*opts.SIGMA


    loglikelihood = -0.5 * ((ymodel - ydata) / yerr)**2
    return loglikelihood

import matplotlib, os, sys
matplotlib.use(os.environ.get("MPL_BACKEND", "Agg"))
import pymultinest


# Run MultiNest
pymultinest.run(loglike, myprior, NP, importance_nested_sampling = True, verbose = True,
        multimodal=False, resume=opts.RESUME, n_iter_before_update=opts.UPDATE,
        evidence_tolerance=opts.TOL, sampling_efficiency = opts.EFF, init_MPI=False,
        n_live_points = opts.POINTS,
        outputfiles_basename='%s/LGNEST'%opts.OUTPUT)

try:
    from mpi4py import MPI
    comm = MPI.COMM_WORLD
    size = comm.Get_size()
    rank = comm.Get_rank()
    print("Rank:", rank, "Size:", size)
#    os.system("cp %s/LGNEST.txt %s/rescue.%i.txt"%(opts.OUTPUT,opts.OUTPUT,rank))
except:
    pass

if rank==0:
    print()
    print("Now analyzing output")
    a = pymultinest.Analyzer(n_params = NP, outputfiles_basename='%s/LGNEST'%opts.OUTPUT)
    s = a.get_stats()


    from collections import OrderedDict
    resraw = a.get_best_fit()["parameters"]
    PP=OrderedDict.fromkeys(PNAMES)
    for num, pname in enumerate(PNAMES):
        PP[pname] = resraw[num]
    for k in FIX:
        PP[k] = FIX[k]
    PP["ordering"]=opts.ORDERING

    LEPTO.setParams(PP)
    BESTVAL=LEPTO.EtaB


    out="# Number of decaying steriles: %i\n"%opts.NDECST
    out+="# Approx: %i\n"%int(opts.APPROX)
    out+="# Best fit value: %e\n"%BESTVAL
    out+="# Best fit point:\n"
    for k in PP:
        if not k in FIX:
            out+= "%s %.16f\n"%(k,PP[k])

    out+="# Fixed parameters were:\n"
    for k in FIX:
        try:
            out+= "%s %f\n"%(k, FIX[k])
        except:
            out+= "%s %f %f i\n"%(k, FIX[k].real, FIX[k].imag)
    with open("%sconfig.best"%a.outputfiles_basename, "w") as f:
        f.write(out)
        f.write("ordering %s"%opts.ORDERING)

    import json
    # store name of parameters, always useful
    with open('%sparams.json' % a.outputfiles_basename, 'w') as f:
            json.dump(PNAMES, f, indent=2)
    with open('%sparams.info' % a.outputfiles_basename, 'w') as f:
        for p in PNAMES:
            f.write("%s\n"%p)
    # store derived stats
    with open('%sstats.json' % a.outputfiles_basename, mode='w') as f:
            json.dump(s, f, indent=2)
    print()
    print("-" * 30, 'ANALYSIS', "-" * 30)
    print("Global Evidence:\n\t%.15e +- %.15e" % ( s['nested sampling global log-evidence'], s['nested sampling global log-evidence error'] ))

    print("Done!")
    import sys
    sys.exit(0)
