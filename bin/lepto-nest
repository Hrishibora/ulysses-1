#!/usr/bin/env python

# from __future__ import division

import os, sys


import optparse, os, sys
op = optparse.OptionParser(usage=__doc__)
op.add_option("-o", "--output",    dest="OUTPUT",      default="nestout", type=str, help="Prefix for outputs (default: %default)")
op.add_option("-v", "--debug",     dest="DEBUG",       default=False, action="store_true", help="Turn on some debug messages")
op.add_option("-q", "--quiet",     dest="QUIET",       default=False, action="store_true", help="Turn off messages")
op.add_option("-m", "--model",     dest="MODEL",       default="3ds", help="Selection of of model")
op.add_option("--seed",            dest="SEED",        default=-1, type=int,              help="Multinest seed (default: %default)")
op.add_option("--sigma",           dest="SIGMA",       default=1, type=int,              help="Switch to inflate the error in likelihood (default: %default)")
op.add_option("--ordering",        dest="ORDERING",    default=0, type=int,                help="The mass ordering (0 or 1, default: %default)")
op.add_option("--nds",             dest="NDECST",      default=1, type=int,                help="Number of decaying steriles (1 or 2, default: %default)")
op.add_option("--approx",          dest="APPROX",      default=False, action='store_true',     help="Use approximate equations (default: %default)")
op.add_option("--testloopdom",     dest="TESTLOOPDOM", default=False, action='store_true',     help="Use approximate equations (default: %default)")
op.add_option("--testtreedom",     dest="TESTTREEDOM", default=False, action='store_true',     help="Use approximate equations (default: %default)")
op.add_option("--mn-resume",       dest="RESUME",      default=False, action='store_true', help="Resume on previous run.")
op.add_option("--mn-multi-mod",    dest="MULTIMODE",   default=False, action='store_true', help="Set multimodal to true.")
op.add_option("--mn-update",       dest="UPDATE",      default=1000, type=int, help="Update inteval (default: %default iterations)")
op.add_option("--mn-tol",          dest="TOL",         default=0.5, type=float, help="Evidence tolerance (default: %default)")
op.add_option("--mn-eff",          dest="EFF",         default=0.8, type=float, help="Sampling efficiency (default: %default)")
op.add_option("--mn-points",       dest="POINTS",      default=400, type=int,              help="Number of live points in PyMultinest (default: %default)")
op.add_option("--mn-imax",         dest="ITMAX",       default=0, type=int, help="Max number of iterations PyMultinest, 0 is infinite (default: %default)")
op.add_option("--mn-multimodal",   dest="MULTIMODAL",  default=False, action='store_true', help="Run in multimodal mode.")
op.add_option("--mn-no-importance",dest="NOIMPSAMP",   default=False, action='store_true', help="Turn off importance sampling.")
opts, args = op.parse_args()

# TODO improve on keywords
MODELS=["1ds", "2ds", "3ds", "3dsscatteringooetaur", "1dsscatteringooetaur", "3dsooetaur", "2dsresonant", "1dszerowidth"]

if opts.MODEL not in MODELS:
    print("Specified model '{}' unknown, please choose from {}".format(opts.MODEL, MODELS))
    sys.exit(1)

if len(args)==0:
    print("No parameter space configuration given, exiting.")
    sys.exit(1)

import leptomts

LEPTO = leptomts.selectLepto(opts.MODEL, opts.APPROX)
if LEPTO is None:
    print("Combination of approx ({}) and model ({}) not implemented, exiting".format(opts.APPROX, opts.MODEL))
    sys.exit(1)

# LEPTO=leptomts.LeptoCalc(nds=opts.NDECST, approx=opts.APPROX)

RNG, FIX = leptomts.readConfig(args[0])

if "M1" in FIX.keys():
    if not "M2" in FIX.keys() and not "M2" in RNG.keys():
        FIX["M2"]=FIX["M1"]+0.5#49831055378960054
    if not "M3" in FIX.keys() and not "M3" in RNG.keys():
        FIX["M3"]=FIX["M2"]+0.5#9831055378960054


# Sanity check for ordering
if opts.ORDERING not in [0,1]:
    print( "Error, ordering has to be either 0 or 1, exiting")
    sys.exit(1)

# Output directory
rank=0
try:
    from mpi4py import MPI
    comm = MPI.COMM_WORLD
    size = comm.Get_size()
    rank = comm.Get_rank()
    print("[%i]/[%i] reporting for duty"%(rank, size))
except Exception as e:
    print("Problem:", e)
    pass

try:
    os.makedirs(opts.OUTPUT)
except:
    pass

print("[%i] Writing output to"%rank, opts.OUTPUT)
# Paramter names
PNAMES = list(RNG.keys())

# Scaling info
PMIN   = [x[0] for x in list(RNG.values())]
PMAX   = [x[1] for x in list(RNG.values())]
PLEN   = [PMAX[i] - PMIN[i] for i in range(len(PMAX))]

# Number of dimensions our problem has
NP = len(PMIN)



def scaleParam(p, idx):
    return PMIN[idx] + p * PLEN[idx]

def myprior(cube, ndim, nparams):
    for i in range(ndim):
        cube[i] = scaleParam(cube[i], i)

def loglike(cube, ndim, nparams):
    PP=[cube[j] for j in range(ndim)]
    pdict=FIX.copy()
    pdict["ordering"]=opts.ORDERING

    for num, p in enumerate(PNAMES):
        pdict[p]=cube[num]

    if "M1" in RNG.keys():
        if not "M2" in FIX.keys() and not "M2" in RNG.keys():
            pdict["M2"]=pdict["M1"]+0.5#49831055378960054
        if not "M3" in FIX.keys() and not "M3" in RNG.keys():
            pdict["M3"]=pdict["M2"]+0.5#9831055378960054

    if opts.DEBUG:
        print( "Testing point", PP)

    LEPTO.setParams(pdict)
    pert = LEPTO.isPerturbative
    if not pert:
        if opts.DEBUG:
            print( "Vetoing point", PP)
        return -1e101

    if opts.TESTTREEDOM:
        meas = LEPTO.FTmeasure()
        if meas > 0.2:
            if opts.DEBUG:
                print( "Vetoing point because it is not tree dominant")
            return -1e101
        if opts.DEBUG:
            return -1e101

    if opts.TESTLOOPDOM:
        meas = LEPTO.FTmeasure()
        if meas > 1.1 or meas < 0.9:
            if opts.DEBUG:
                print( "Vetoing point because it is not loop dominant")
            return -1e101

    ymodel = LEPTO(pdict)
    # except:
        # print( "Something went wrong at", PP, "vetoing")
        # return -1e101

    if opts.DEBUG:
        print("response", ymodel)

    ydata = 6.10e-10
    yerr  = 0.04e-10*opts.SIGMA


    loglikelihood = -0.5 * ((ymodel - ydata) / yerr)**2
    return loglikelihood

import matplotlib, os, sys
matplotlib.use(os.environ.get("MPL_BACKEND", "Agg"))

# Run MultiNest
import pymultinest
pymultinest.run(loglike, myprior, NP,
        importance_nested_sampling = not opts.NOIMPSAMP,
        verbose = False if opts.QUIET else True,
        multimodal=opts.MULTIMODAL,
        resume=opts.RESUME,
        n_iter_before_update=opts.UPDATE,
        evidence_tolerance=opts.TOL,
        sampling_efficiency = opts.EFF,
        init_MPI=False,
        n_live_points = opts.POINTS,
        max_iter=opts.ITMAX,
        seed=opts.SEED,
        outputfiles_basename='%s/LGNEST'%opts.OUTPUT)

try:
    from mpi4py import MPI
    comm = MPI.COMM_WORLD
    size = comm.Get_size()
    rank = comm.Get_rank()
    print("Rank:", rank, "Size:", size)
#    os.system("cp %s/LGNEST.txt %s/rescue.%i.txt"%(opts.OUTPUT,opts.OUTPUT,rank))
except:
    pass

if rank==0:
    print()
    print("Now analyzing output")
    a = pymultinest.Analyzer(n_params = NP, outputfiles_basename='%s/LGNEST'%opts.OUTPUT)
    s = a.get_stats()


    from collections import OrderedDict
    resraw = a.get_best_fit()["parameters"]
    PP=OrderedDict.fromkeys(PNAMES)
    for num, pname in enumerate(PNAMES):
        PP[pname] = resraw[num]
    for k in FIX:
        PP[k] = FIX[k]
    PP["ordering"]=opts.ORDERING

    LEPTO.setParams(PP)
    BESTVAL=LEPTO.EtaB


    out="# Number of decaying steriles: %i\n"%opts.NDECST
    out+="# Approx: %i\n"%int(opts.APPROX)
    out+="# Best fit value: %e\n"%BESTVAL
    out+="# Best fit point:\n"
    for k in PP:
        if not k in FIX:
            out+= "%s %.16f\n"%(k,PP[k])

    out+="# Fixed parameters were:\n"
    for k in FIX:
        try:
            out+= "%s %f\n"%(k, FIX[k])
        except:
            out+= "%s %f %f i\n"%(k, FIX[k].real, FIX[k].imag)
    with open("%sconfig.best"%a.outputfiles_basename, "w") as f:
        f.write(out)
        f.write("ordering %s"%opts.ORDERING)

    import json
    # store name of parameters, always useful
    with open('%sparams.json' % a.outputfiles_basename, 'w') as f:
            json.dump(PNAMES, f, indent=2)
    with open('%sparams.info' % a.outputfiles_basename, 'w') as f:
        for p in PNAMES:
            f.write("%s\n"%p)
    # store derived stats
    with open('%sstats.json' % a.outputfiles_basename, mode='w') as f:
            json.dump(s, f, indent=2)
    print()
    print("-" * 30, 'ANALYSIS', "-" * 30)
    print("Global Evidence:\n\t%.15e +- %.15e" % ( s['nested sampling global log-evidence'], s['nested sampling global log-evidence error'] ))

    print("Done!")
    import sys
    sys.exit(0)
